using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Mathematics;
using Unity.Transforms;
using UnityEditor;
using UnityEngine;

public partial class ExploitationSystem : SystemBase
{
    [BurstCompile]
    [WithAll(typeof(ActorTag), typeof(ExploitationTag))]
    [WithNone(typeof(MoveTo), typeof(MazeDisplacment))]
    private partial struct SolveJob : IJobEntity
    {
        public EntityCommandBuffer command;
        [ReadOnly]
        public NativeParallelMultiHashMap<int2, ActionAndQValue> state;
        [ReadOnly]
        public NativeHashMap<int2, bool> maze;
        public Unity.Mathematics.Random random;
        public int2 endCheckPointCell;

        [BurstCompile]
        void Execute(
            Entity entity,
            in LocalTransform transform)
        {
            var currentCell = (int2)transform.Position.xz;

            if (IsWon(currentCell))
            {
                command.DestroyEntity(entity);
                return;
            }


            var action = GetBestOrRandomAction(currentCell);
            var nextCell = currentCell + MazeMethods.DirectionToDisplacment(action);

            if (IsInWall(nextCell)) return;

            command.AddComponent(entity, new MoveTo
            {
                to = nextCell,
            });
        }

        Direction GetBestOrRandomAction(int2 currentCell)
        {
            var actions = GetBestActions(currentCell);

            return actions[random.NextInt(0, actions.Length)].action;
        }

        [BurstCompile]
        ActionAndQValue GetBestAction(int2 currentCell)
        {
            var exist = state.TryGetFirstValue(currentCell, out var data, out var it);
            var best = data;

            while (exist)
            {
                if (data.qValue > best.qValue)
                {
                    best = data;
                }
                exist = state.TryGetNextValue(out data, ref it);
            }

            return best;
        }

        NativeList<ActionAndQValue> GetBestActions(int2 currentCell)
        {
            var bestAction = GetBestAction(currentCell);
            var res = new NativeList<ActionAndQValue>(4, Allocator.Temp);

            var exist = state.TryGetFirstValue(currentCell, out var data, out var it);

            while (exist)
            {
                if (data.qValue == bestAction.qValue)
                {
                    res.AddNoResize(data);
                }
                exist = state.TryGetNextValue(out data, ref it);
            }

            return res;
        }

        bool IsWon(int2 position)
        {
            return position.x == endCheckPointCell.x && position.y == endCheckPointCell.y;
        }

        bool IsInWall(int2 position)
        {
            var isRoad = maze.TryGetValue(position, out _);
            return !isRoad;
        }
    }

    protected override void OnCreate()
    {
        RequireForUpdate<MazeEndTag>();
        RequireForUpdate<ExploitationTag>();
    }

    protected override void OnUpdate()
    {
        var commandSystem = SystemAPI.GetSingleton<BeginInitializationEntityCommandBufferSystem.Singleton>();
        var command = commandSystem.CreateCommandBuffer(World.Unmanaged);
        var endCheckPoint = SystemAPI.GetSingletonEntity<MazeEndTag>();
        var endCheckPointCell = (int2)SystemAPI.GetComponent<LocalTransform>(endCheckPoint).Position.xz;

        Dependency = new SolveJob
        {
            command = command,
            state = ExplorationSystem.MazeState,
            maze = GenerateMazeSystem.MazeCells,
            random = Unity.Mathematics.Random.CreateFromIndex((uint)(SystemAPI.Time.ElapsedTime * 1000) + 1),
            endCheckPointCell = endCheckPointCell,
        }.Schedule(Dependency);
        CompleteDependency();
    }
}